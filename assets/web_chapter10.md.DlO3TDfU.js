import{_ as l,c as e,o as r,a2 as a}from"./chunks/framework.DpuVf8Pb.js";const d=JSON.parse('{"title":"前后端协作规范","description":"","frontmatter":{},"headers":[],"relativePath":"web/chapter10.md","filePath":"web/chapter10.md"}'),i={name:"web/chapter10.md"},t=a('<h1 id="前后端协作规范" tabindex="-1">前后端协作规范 <a class="header-anchor" href="#前后端协作规范" aria-label="Permalink to &quot;前后端协作规范&quot;">​</a></h1><p>前端是Web的一个细分领域，往往不能脱离后端而存在，所以和后端协作的时间是最长的。</p><h2 id="协作流程规范" tabindex="-1">协作流程规范 <a class="header-anchor" href="#协作流程规范" aria-label="Permalink to &quot;协作流程规范&quot;">​</a></h2><p>前后端团队经过长期的合作，一般可以总结出一条对于双方开发效率最优的协作流程. 将这个落实为规范，后面的团队成员都遵循这个步调进行协作。</p><p>一个典型的前后端协作流程如下:</p><p><img src="https://pic-go-1256738511.cos.ap-chengdu.myqcloud.com/images/20201103160822.png" alt="chapter10_1"></p><ol><li><p>需求分析。参与者一般有前后端、测试、以及产品. 由产品主持，对需求进行宣贯，接受开发和测试的反馈，确保大家对需求有一致的认知。</p></li><li><p>前后端开发讨论。讨论应用的一些开发设计，沟通技术点、难点、以及分工问题。</p></li><li><p>设计接口文档。可以由前后端一起设计；或者由后端设计、前端确认是否符合要求。</p></li><li><p>并行开发。前后端并行开发，在这个阶段，前端可以先实现静态页面; 或者根据接口文档对接口进行Mock, 来模拟对接后端接口。</p></li><li><p>在联调之前，要求后端做好接口测试。</p></li><li><p>真实环境联调。前端将接口请求代理到后端服务，进行真实环境联调。</p></li></ol><h2 id="接口规范" tabindex="-1">接口规范 <a class="header-anchor" href="#接口规范" aria-label="Permalink to &quot;接口规范&quot;">​</a></h2><p>首先应该确定下来的是接口规范。其实使用哪种接口标准是其次，重要的是统一，且要满足前后端的开发效率要求.</p><p>笔者不建议后端去定义自己的接口标准，而应该去选择一些通用的、有标准定义接口形式, 例如:</p><ul><li><p><a href="https://zh.wikipedia.org/zh-hans/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" target="_blank" rel="noreferrer">RESTful</a>: RESTful是目前使用最为广泛的API设计规范, 基于HTTP本身的机制来实现。</p><p>笔者个人是比较喜欢这个API规范，但是我发现很多开发者并不能真正(或者说没心思)理解它，设计出来的接口，跟我想象的相差甚远。换句话说，对于RESTful，开发者之间很难达成一致的理解，容易产生分歧。</p><p>因为是使用最广泛的API形式，所以社区上有很多工具来对RESTful接口进行文档化、测试和模拟。</p></li><li><p><a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html" target="_blank" rel="noreferrer">JSONRPC</a> 这是一种非常简单、容易理解的接口规范。相对于RESTful我更推荐这个，简单则不容易产生分歧，新手也可以很快接受。</p></li><li><p><a href="https://graphql.org/learn/" target="_blank" rel="noreferrer">GraphQL</a> 🔥更为先进、更有前景的API规范。但是你要说服后端配合你使用这种标准可能很有难度。</p></li></ul><p><strong>接口设计需要注意的点</strong>:</p><ul><li>明确区分是正常还是异常, 严格遵循接口的异常原语. 上述接口形式都有明确的异常原语，比如JSONRPC，当出现异常时应该返回<code>错误对象</code>响应，而不是在正常的响应体中返回错误代码. 另外要规范化的错误码, HTTP响应码就是一个不错的学习对象</li><li>明确数据类型。很多后端写的接口都是string和number不分的，如果妥协的话、前端就需要针对这个属性做特殊处理，这也可能是潜在的bug</li><li>明确空值的意义。比如在做更新操作是，空值是表示重置，还是忽略更新？</li><li>响应避免冗余的嵌套。</li><li>接口版本化，保持向下兼容。就像我们上文的‘语义化版本规范’说的，对于后端来说，API就是公共的接口. 公共暴露的接口应该有一个版本号，来说明当前描述的接口做了什么变动，是否向下兼容。 现在前端代码可能会在客户端被缓存，例如小程序。如果后端做了break change，就会影响这部分用户。</li></ul><h2 id="接口文档规范" tabindex="-1">接口文档规范 <a class="header-anchor" href="#接口文档规范" aria-label="Permalink to &quot;接口文档规范&quot;">​</a></h2><p>后端通过接口文档向前端暴露接口相关的信息。通常需要包含这些信息：</p><ul><li>版本号</li><li>文档描述</li><li>服务的入口. 例如基本路径</li><li>测试服务器. 可选</li><li>简单使用示例</li><li>安全和认证</li><li>具体接口定义 <ul><li>方法名称或者URL</li><li>方法描述</li><li>请求参数及其描述，必须说明类型(数据类型、是否可选等)</li><li>响应参数及其描述, 必须说明类型(数据类型、是否可选等)</li><li>可能的异常情况、错误代码、以及描述</li><li>请求示例，可选</li></ul></li></ul><p><strong>人工维护导致的问题</strong>:</p><p>上文‘代码即文档’就提到了人工维护接口文档可能导致代码和文档不同步问题。</p><p>如果可以从代码或者规范文档(例如OpenAPI这类API描述规范)中生成接口文档，可以解决实现和文档不一致问题, 同时也可以减少文档编写和维护的投入。</p><h2 id="接口测试与模拟" tabindex="-1">接口测试与模拟 <a class="header-anchor" href="#接口测试与模拟" aria-label="Permalink to &quot;接口测试与模拟&quot;">​</a></h2><p>为了做到高效率的前后端并行开发，接口的测试与模拟是必要的。</p><ul><li>前端要求后端在联调之前，需要测试验证好自己的接口是否可以正常工作。而不是在联调期间，把前端当‘接口测试员’，阻塞接口联调进度</li><li>另外前端需要在后端接口未准备好之前，通过接口模拟的方式，来编写业务逻辑代码。</li></ul><p>针对接口测试与模拟，存在下图这样一个理想的模型:</p><p><img src="https://pic-go-1256738511.cos.ap-chengdu.myqcloud.com/images/20201103160828.png" alt="chapter10_2"></p><p>一切从定义良好的接口文档出发，生成<code>Mock Server</code>和<code>Mock Client</code>, Mock Server给前端提供模拟数据，而Mock Client则辅助后端对它们的接口进行测试。</p><p>资源:</p><ul><li>RESTful <ul><li><a href="https://swagger.io/" target="_blank" rel="noreferrer">Swagger</a> 这是最为接近上面理想模型的一个解决方案</li><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noreferrer">JSON Server</a> 快速生成JSON mock服务器</li><li><a href="https://easy-mock.com" target="_blank" rel="noreferrer">Easy Mock</a> 可视化的、在线的接口mock服务</li></ul></li><li>GraphQl <ul><li><a href="https://github.com/APIs-guru/graphql-faker" target="_blank" rel="noreferrer">GraphQL Faker</a></li><li><a href="https://www.apollographql.com/docs/graphql-tools/mocking/" target="_blank" rel="noreferrer">graphql-tools</a></li></ul></li><li>模拟数据生成 <ul><li><a href="https://github.com/Marak/faker.js" target="_blank" rel="noreferrer">faker.js</a> 🔥强大的模拟数据生成工具，支持Node和浏览器</li><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noreferrer">Mock.js</a> 数据生成和模拟工具</li></ul></li></ul>',27),o=[t];function p(c,h,n,s,u,g){return r(),e("div",null,o)}const _=l(i,[["render",p]]);export{d as __pageData,_ as default};
