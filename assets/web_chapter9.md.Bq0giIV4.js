import{_ as e,c as r,o as a,a2 as t}from"./chunks/framework.DlC1fzyH.js";const b=JSON.parse('{"title":"异常处理、监控和调试规范","description":"","frontmatter":{},"headers":[],"relativePath":"web/chapter9.md","filePath":"web/chapter9.md"}'),l={name:"web/chapter9.md"},o=t('<h1 id="异常处理、监控和调试规范" tabindex="-1">异常处理、监控和调试规范 <a class="header-anchor" href="#异常处理、监控和调试规范" aria-label="Permalink to &quot;异常处理、监控和调试规范&quot;">​</a></h1><p>很多开发者常常误用或者轻视异常的处理, 合理有效的异常处理可以提高应用的健壮性和可用性，另外还可以帮助开发者快速定位异常。</p><h2 id="异常处理" tabindex="-1">异常处理 <a class="header-anchor" href="#异常处理" aria-label="Permalink to &quot;异常处理&quot;">​</a></h2><p>&lt;阿里巴巴的Java开发手册&gt;中总结的<a href="https://github.com/alibaba/p3c/blob/master/p3c-gitbook/%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.md" target="_blank" rel="noreferrer">异常处理规范</a>对JavaScript的异常处理也很有参考意义，比如:</p><ul><li>异常不要用来做流程控制，条件控制。</li><li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li><li>catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。不要对大段代码进行try-catch</li><li>...</li></ul><p>然后再根据JavaScript本身的异常处理特点总结一些规范行为, 例如:</p><ul><li>不要throw非Error对象</li><li>不要忽略异步异常</li><li>全局监控Javascript异常</li><li>...</li></ul><p>资源:</p><ul><li><a href="https://rollbar.com/blog/top-10-javascript-errors/" target="_blank" rel="noreferrer">从1000+个项目中总结出来的前10个JavaScript错误, 以及如何避免它们</a></li><li><a href="https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6" target="_blank" rel="noreferrer">Javascript异常处理‘权威’指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/63698500" target="_blank" rel="noreferrer">前端异常处理最佳实践</a></li></ul><h2 id="日志" tabindex="-1">日志 <a class="header-anchor" href="#日志" aria-label="Permalink to &quot;日志&quot;">​</a></h2><p>对于前端来说，日志也不是毫无意义(很多框架性能优化建议在生产环境移除console)。尤其是在<strong>生产现场</strong>调试代码时，这时候可贵的控制台日志可以帮助你快速找到异常的线索。</p><p>不过通常我们<strong>只要保留必要的、有意义的日志输出</strong>，比如你不应该将console.log放到一个React渲染函数中、或者放到一个循环中, <strong>DDos式的日志信息并不能帮助我们定位问题，反而会影响运行的性能</strong>. 所以需要一个规范来约束日志输出行为, 比如:</p><ul><li>避免重复打印日志</li><li>谨慎地记录日志, 划分日志级别。比如生产环境禁止输出debug日志；有选择地输出info日志；</li><li>使用前缀对日志进行分类, 例如: <code>[User] xxxx</code></li><li>只记录关键信息, 这些信息可以帮助你诊断问题</li><li>...</li></ul><p>扩展资源</p><ul><li><a href="https://github.com/visionmedia/debug" target="_blank" rel="noreferrer">debug</a> 适合Node.js和浏览器的debug日志工具, 支持动态开启日志打印</li><li><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noreferrer">vConsole</a> 移动端调试利器</li></ul><h2 id="异常监控" tabindex="-1">异常监控 <a class="header-anchor" href="#异常监控" aria-label="Permalink to &quot;异常监控&quot;">​</a></h2><p>因为程序跑在不受控的环境，所以对于客户端应用来说，异常监控在生产环境是非常重要的，它可以收集各种意料之外生产环境问题，帮助开发者快速定位异常。</p><p>异常监控通常会通过三种方式来收集异常数据:</p><ol><li>全局捕获。例如使用window.onerror, 或者<code>unhandledrejection</code></li><li>主动上报。在try/catch中主动上报.</li><li>用户反馈。比如弹窗让用户填写反馈信息.</li></ol><p>和日志一样，<strong>不是所有‘异常’都应该上报给异常监控系统，譬如一些预料之内的‘异常’</strong>，比如用户输入错误、鉴权失败、网络错误等等. <strong>异常监控主要用来上报一些意料之外的、或者致命性的异常</strong>.</p><p>要做好前端的异常监控其实并不容易，它需要处理这些东西:</p><ul><li>浏览器兼容性。</li><li>碎片收集(breadcrumbs)。 收集‘灾难’现场的一些线索，这些线索对问题诊断很重要。例如当前用户信息、版本、运行环境、打印的日志、函数调用栈等等</li><li>调用栈的转换。通常在浏览器运行的压缩优化过的代码，这种调用栈基本没什么可读性，通常需要通过SourceMap映射到原始代码. 可以使用这个库: <a href="https://github.com/mozilla/source-map#sourcemapconsumer" target="_blank" rel="noreferrer">source-map</a></li><li>数据的聚合。后端监控系统需要对前端上报的信息进行分析和聚合</li></ul><p>对于小团队未必有能力开发这一套系统，所以推荐使用一些第三方工具。例如</p><ul><li><a href="https://sentry.io/welcome/" target="_blank" rel="noreferrer">Sentry</a> 🔥免费基本够用</li><li><a href="https://www.fundebug.com/price" target="_blank" rel="noreferrer">FunDebug</a> 付费增强</li></ul><p><strong>扩展</strong>:</p><ul><li><a href="https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/" target="_blank" rel="noreferrer">前端异常监控解决方案研究</a></li><li><a href="https://www.cnblogs.com/warm-stranger/p/9417084.html" target="_blank" rel="noreferrer">搭建前端监控系统</a></li></ul>',26),i=[o];function n(c,s,p,h,u,d){return a(),r("div",null,i)}const f=e(l,[["render",n]]);export{b as __pageData,f as default};
